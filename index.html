<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Mindmap App</title>

    <!-- 
         allows resources (such as images, stylesheets, and scripts) to be loaded only from the same origin (i.e., your app itself) 
         script-src 'self' specifically allows scripts to be executed only if they are loaded from the same origin. 
    -->

    <!-- adding this currently makes it function odd. TODO: look into to see if this is needed-->
    <!-- <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'" /> -->

    <style>

      * {
        font-family: sans-serif;
      }

      html {
        background: #f1f1f1
      }

      h2 {
        font-weight: normal;
        font-size: 16px;
      }

      button {
        padding: 0.5rem;
        border-color: #e7e7e7;
        border-radius: 5px;
        border-style: solid;
        background: white;
        margin: 0 0.25rem;
        cursor: pointer;
      }
      button:hover {
        background: rgb(226, 226, 226);
      }

      input[type="text"] {
        padding: 1rem;
        border: none;
        border-radius: 5px;
        background-color: #e9e9e9;
      }


        #customDialog {
          position: fixed; /* Use fixed positioning */
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%); /* Center the dialog */
          z-index: 1000; /* Ensure it's above other content */
          background-color: white; /* Background color */
          border: 1px solid #ccc; /* Border to look like a box */
          border-radius: 5px; /* Optional: rounded corners */
          padding: 20px; /* Padding inside the dialog */
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Optional: add some shadow for depth */
          display: none; /* Start hidden */
        }

        /* Overlay covering the entire screen */
        #dialogOverlay {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent black background */
          z-index: 999; /* Just below the dialog to cover other elements */
          display: none; /* Start hidden */
        }


        #svg-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        .node {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 0.5rem;
            cursor: move;
            user-select: none;
            z-index: 1;
            text-align: center;
        }
        .node.selected {
            border: 2px solid #007bff;
        }
        .connector {
            fill: none;
            stroke: #3c94f8;
            stroke-width: 2;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
        }
        #importInput {
            display: none;
        }

        .node-text {
            pointer-events: none;
            padding: 0.5rem;
        }

        .node button {
          opacity: 0.3;
          transition: opacity 0.3s;
          /* border: 1px solid transparent; */
          border: none;
        }
        .node:hover button {
          opacity: 0.7;
          /* border: 1px solid rgb(182, 182, 182); */
        }

    </style>
</head>
<body>
    <svg id="svg-container"></svg>
    <div id="mindmap"></div>
    <div id="controls">
        <button id="exportBtn">
          <img class="icon" src="./icons/download.svg" />
        </button>
        <button id="importBtn">
          <img class="icon" src="./icons/file-plus.svg" />
        </button>
        <input type="file" id="importInput" accept=".json">
    </div>

    <div id="dialogOverlay"></div>
    <div id="customDialog">
      <h2>Edit Node</h2>
      <input type="text" id="textInput" placeholder="Enter text here">
      <button id="okButton">OK</button>
      <button id="cancelButton">Cancel</button>
    </div>

    <script>
        const mindmap = document.getElementById('mindmap');
        const svgContainer = document.getElementById('svg-container');
        const exportBtn = document.getElementById('exportBtn');
        const importBtn = document.getElementById('importBtn');
        const importInput = document.getElementById('importInput');
        let nodeId = 0;
        let draggedNode = null;
        let offsetX, offsetY;
        let selectedNode = null;
        let initialDragPosition = { x: 0, y: 0 };
        let rootNode = null;

        function createNode(x, y, parent = null, id = null, content = null, isAddingDeleteButton = true) {
            const node = document.createElement('div');
            node.className = 'node';
            node.id = id || `node-${nodeId++}`;
            node.style.left = `${x}px`;
            node.style.top = `${y}px`;

            // put text content in new span
            const text = document.createElement('div');
            text.className = 'node-text';
            text.textContent = content || `Node ${node.id}`;
            node.appendChild(text);

            node.addEventListener('dblclick', () => editNode(node));
            node.addEventListener('mousedown', dragStart);
            node.addEventListener('click', selectNode);


            // Create add child button or the node
            const addChildBtn = document.createElement('button');
            addChildBtn.innerHTML = '<img class="icon" src="./icons/plus.svg" />';
            addChildBtn.className = 'add-child-btn'; // For styling
            addChildBtn.title = 'Add Child';
            addChildBtn.onclick = (event) => {
                event.stopPropagation(); // Prevent click event from bubbling to parent nodes
                addNode(node); // Assuming you want to pass the node's id, not the uninitialized 'id' variable
            };
            node.appendChild(addChildBtn);

            // Create edit button
            const editBtn = document.createElement('button');
            editBtn.innerHTML = '<img class="icon" src="./icons/edit-3.svg" />';
            editBtn.className = 'edit-btn'; // For styling
            editBtn.title = 'Edit Name';
            editBtn.onclick = (event) => {
                event.stopPropagation(); // Prevent click event from bubbling to parent nodes
                editNode(node); // Assuming you want to pass the node's id, not the uninitialized 'id' variable
            };
            node.appendChild(editBtn);

            // Create delete button
            if(isAddingDeleteButton) {
              const deleteBtn = document.createElement('button');
              deleteBtn.textContent = 'Delete';
              deleteBtn.innerHTML = '<img class="icon" src="./icons/x.svg" />';
              deleteBtn.className = 'delete-btn'; // For styling
              deleteBtn.title = 'Delete';
              deleteBtn.onclick = (event) => {
                event.stopPropagation(); // Prevent click event from bubbling to parent nodes
                deleteNode(node);
                updateConnectors();
              };
              node.appendChild(deleteBtn);
            }

            mindmap.appendChild(node);

            if (parent) {
                drawConnector(parent, node);
            }

            return node;
        }

        function editNode(node) {
            showDialog(node);
        }

        function isDialogOpen() {
            const dialog = document.getElementById('customDialog');

            if(dialog) {
              return dialog.style.display !== 'none';
            }

            return false
        }

        function confirmDialog() {
          selectedNode.getElementsByClassName('node-text')[0].textContent = document.getElementById('textInput').value;
          hideDialog();
        }

        // Event listeners for OK and Cancel buttons
        document.getElementById('okButton').addEventListener('click', function() {
          confirmDialog();
        });

        document.getElementById('cancelButton').addEventListener('click', function() {
          // Simply hide the dialog
          hideDialog();
        });


        document.addEventListener('keydown', function(event) {

            if (event.key === 'Enter' && isDialogOpen()) {
                // Close the dialog or perform any action when the dialog is open and Enter is pressed
                confirmDialog(); // Assuming you have a function to close the dialog
            }
        });


        // Function to show the dialog
        function showDialog(node) {
          document.getElementById('dialogOverlay').style.display = 'block';
          document.getElementById('customDialog').style.display = 'block';

          // get the node-text element's content and place it in input
          document.getElementById('textInput').value = node.getElementsByClassName('node-text')[0].textContent;
          document.getElementById('textInput').focus();
          document.getElementById('textInput').select();

        }

        // Function to hide the dialog
        function hideDialog() {
          document.getElementById('dialogOverlay').style.display = 'none';
          document.getElementById('customDialog').style.display = 'none';
        }

        function drawConnector(parent, child) {
            const connector = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            connector.setAttribute('class', 'connector');
            connector.setAttribute('data-parent', parent.id);
            connector.setAttribute('data-child', child.id);
            updateConnector(parent, child, connector);
            svgContainer.appendChild(connector);
        }

        function updateConnector(parent, child, connector) {
          const parentRect = parent.getBoundingClientRect();
          const childRect = child.getBoundingClientRect();
          const px = parentRect.left + parentRect.width / 2;
          const py = parentRect.top + parentRect.height / 2;
          const cx = childRect.left + childRect.width / 2;
          const cy = childRect.top + childRect.height / 2;

          // Calculate the angle in radians between the parent and child nodes
          const angle = Math.atan2(cy - py, cx - px);

          // Adjust the curvature based on the angle
          const curvatureFactor = Math.abs(Math.sin(angle)); // Example adjustment, feel free to modify

          const midX = (px + cx) / 2;
          const midY = (py + cy) / 2;
          const dx = cx - px;
          const dy = cy - py;

          // Determine if the child is below the parent and adjust the curve direction
          const isChildBelow = cy > py;
          const curveDirection = isChildBelow ? -1 : 1;

          // Apply curvature factor to control the shape dynamically, adjusting direction based on child's position
          const curveX = midX + dy * 0.5 * curvatureFactor * curveDirection;
          const curveY = midY - dx * 0.5 * curvatureFactor * curveDirection;

          const path = `M${px},${py} Q${curveX},${curveY} ${cx},${cy}`;
          connector.setAttribute('d', path);
        }

        function dragStart(e) {
            e.stopPropagation();
            draggedNode = e.target;
            const rect = draggedNode.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            initialDragPosition = { x: e.clientX, y: e.clientY };

            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', dragEnd);
        }

        function drag(e) {
            if (draggedNode) {
                const dx = e.clientX - initialDragPosition.x;
                const dy = e.clientY - initialDragPosition.y;
                moveNodeAndDescendants(draggedNode, dx, dy);
                initialDragPosition = { x: e.clientX, y: e.clientY };
                updateConnectors();
            }
        }

        function moveNodeAndDescendants(node, dx, dy) {
            const currentX = parseInt(node.style.left);
            const currentY = parseInt(node.style.top);
            node.style.left = `${currentX + dx}px`;
            node.style.top = `${currentY + dy}px`;

            const children = getChildren(node);
            children.forEach(child => moveNodeAndDescendants(child, dx, dy));
        }

        function dragEnd() {
            draggedNode = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('mouseup', dragEnd);
        }

        function updateConnectors() {
            const connectors = svgContainer.getElementsByClassName('connector');
            Array.from(connectors).forEach(connector => {
                const parent = document.getElementById(connector.getAttribute('data-parent'));
                const child = document.getElementById(connector.getAttribute('data-child'));
                if (parent && child) {
                    updateConnector(parent, child, connector);
                }
            });
        }

        function selectNode(e) {

            if (selectedNode) {
                selectedNode.classList.remove('selected');
            }
            selectedNode = e.target;
            selectedNode.classList.add('selected');
        }

        function deleteNode(node) {
            const children = getChildren(node);
            children.forEach(child => deleteNode(child));

            const connectors = svgContainer.querySelectorAll(`[data-parent="${node.id}"], [data-child="${node.id}"]`);
            connectors.forEach(connector => connector.remove());

            node.remove();

            if (selectedNode === node) {
                selectedNode = null;
            }
        }

        function getChildren(node) {
            const connectors = svgContainer.querySelectorAll(`[data-parent="${node.id}"]`);
            return Array.from(connectors).map(connector => 
                document.getElementById(connector.getAttribute('data-child'))
            );
        }

        function getParent(node) {
            const connector = svgContainer.querySelector(`[data-child="${node.id}"]`);
            return connector ? document.getElementById(connector.getAttribute('data-parent')) : null;
        }

        function exportMindmap() {
            const nodes = Array.from(document.getElementsByClassName('node'));
            const connectors = Array.from(svgContainer.getElementsByClassName('connector'));

            const mindmapData = {
                nodes: nodes.map(node => ({
                    id: node.id,
                    content: node.textContent,
                    x: parseInt(node.style.left),
                    y: parseInt(node.style.top)
                })),
                connectors: connectors.map(connector => ({
                    parent: connector.getAttribute('data-parent'),
                    child: connector.getAttribute('data-child')
                }))
            };

            const jsonData = JSON.stringify(mindmapData, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'mindmap.json';
            a.click();

            URL.revokeObjectURL(url);
        }

        function importMindmap(jsonData) {
            const mindmapData = JSON.parse(jsonData);

            // Clear existing mindmap
            mindmap.innerHTML = '';
            svgContainer.innerHTML = '';

            // Create nodes
            mindmapData.nodes.forEach(nodeData => {
                createNode(nodeData.x, nodeData.y, null, nodeData.id, nodeData.content);
            });

            // Create connectors
            mindmapData.connectors.forEach(connectorData => {
                const parent = document.getElementById(connectorData.parent);
                const child = document.getElementById(connectorData.child);
                if (parent && child) {
                    drawConnector(parent, child);
                }
            });

            // Set root node
            rootNode = document.getElementById(mindmapData.nodes[0].id);
            selectNode({ target: rootNode });

            updateConnectors();
        }

        function addNode(baseNode) {
            const offset = 40; // Offset both below and to the right

            let referenceNode = baseNode;
            const children = getChildren(baseNode); // Assuming children have a class 'node'
            if (children.length > 0) {
                referenceNode = children[children.length - 1]; // Use the last child as reference
            }

            // Get the reference node's position
            const referenceRect = referenceNode.getBoundingClientRect();

            // 
            let newX = referenceRect.right + offset 
             if (children.length > 0) {
               newX -= baseNode.getBoundingClientRect().right // if we are another child, just be it underneath
             }

            let newY = referenceRect.bottom + offset

            // Assuming createNode is a function that creates the new node
            createNode(newX, newY, baseNode); // Pass additional parameters as needed
        }

        exportBtn.addEventListener('click', exportMindmap);

        importBtn.addEventListener('click', () => {
            importInput.click();
        });

        importInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    importMindmap(e.target.result);
                };
                reader.readAsText(file);
            }
        });

        // Create initial node
        const isAddingDeleteButton = false
        rootNode = createNode(100, 100, null, null, 'Root Node', isAddingDeleteButton);
        selectNode({ target: rootNode });
    </script>
</body>
</html>